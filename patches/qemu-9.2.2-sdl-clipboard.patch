--- a/ui/sdl2.c.orig	2025-01-01 00:00:00.000000000 +0000
+++ b/ui/sdl2.c	2025-01-01 00:00:00.000000000 +0000
@@ -40,6 +40,10 @@
 #include "ui/win32-kbd-hook.h"
 #endif
 
+#if SDL_VERSION_ATLEAST(2, 26, 0)
+#include <SDL_clipboard.h>
+#endif
+
 static int sdl2_num_outputs = 0;
 static struct sdl2_console *sdl2_console;
 
@@ -617,6 +621,94 @@ static void sdl_mouse_warp(DisplayChange
     SDL_WarpMouseInWindow(scon->real_window, x, y);
 }
 
+#if SDL_VERSION_ATLEAST(2, 26, 0)
+static void sdl_clipboard_notify(Notifier *notifier, void *data)
+{
+    QemuClipboardInfo *info = data;
+    QemuClipboardSelection selection = info->selection;
+    QemuClipboardType type;
+    g_autoptr(QemuClipboardInfo) cbinfo = NULL;
+    char *text;
+
+    if (selection != QEMU_CLIPBOARD_SELECTION_CLIPBOARD) {
+        return;
+    }
+
+    if (info->owner == &sdl_clipboard_peer) {
+        return;
+    }
+
+    for (type = 0; type < QEMU_CLIPBOARD_TYPE__COUNT; type++) {
+        if (info->types[type].available && info->types[type].data) {
+            switch (type) {
+            case QEMU_CLIPBOARD_TYPE_TEXT:
+                text = g_strndup((char *)info->types[type].data,
+                                 info->types[type].size);
+                if (SDL_SetClipboardText(text) < 0) {
+                    warn_report("SDL clipboard write failed: %s",
+                               SDL_GetError());
+                }
+                g_free(text);
+                break;
+            default:
+                break;
+            }
+        }
+    }
+}
+
+static void sdl_clipboard_request(QemuClipboardInfo *info,
+                                  QemuClipboardType type)
+{
+    char *text;
+
+    switch (type) {
+    case QEMU_CLIPBOARD_TYPE_TEXT:
+        text = SDL_GetClipboardText();
+        if (text) {
+            qemu_clipboard_set_data(&sdl_clipboard_peer, info, type,
+                                    strlen(text), text, true);
+            SDL_free(text);
+        }
+        break;
+    default:
+        break;
+    }
+}
+
+static void sdl_clipboard_update(void)
+{
+    g_autoptr(QemuClipboardInfo) info = NULL;
+
+    if (!SDL_HasClipboardText()) {
+        return;
+    }
+
+    info = qemu_clipboard_info_new(&sdl_clipboard_peer,
+                                   QEMU_CLIPBOARD_SELECTION_CLIPBOARD);
+    info->types[QEMU_CLIPBOARD_TYPE_TEXT].available = true;
+    qemu_clipboard_update(info);
+}
+
+static void sdl_clipboard_reset(void)
+{
+    g_autoptr(QemuClipboardInfo) info = NULL;
+
+    info = qemu_clipboard_info_new(&sdl_clipboard_peer,
+                                   QEMU_CLIPBOARD_SELECTION_CLIPBOARD);
+    qemu_clipboard_update(info);
+}
+
+static QemuClipboardPeer sdl_clipboard_peer = {
+    .name = "sdl2",
+    .notifier = { .notify = sdl_clipboard_notify },
+    .request = sdl_clipboard_request,
+};
+
+static Notifier sdl_clipboard_notifier = {
+    .notify = sdl_clipboard_notify
+};
+#endif
+
 static void sdl_mouse_define(DisplayChangeListener *dcl,
                              QEMUCursor *c)
 {
@@ -827,6 +919,14 @@ static void sdl2_display_init(DisplaySt
         SDL_SetHint(SDL_HINT_GRAB_KEYBOARD, "1");
     }
 
+#if SDL_VERSION_ATLEAST(2, 26, 0)
+    if (qemu_clipboard_peer_owns(&sdl_clipboard_peer,
+                                QEMU_CLIPBOARD_SELECTION_CLIPBOARD)) {
+        sdl_clipboard_reset();
+    }
+    qemu_clipboard_peer_register(&sdl_clipboard_peer);
+#endif
+
     memset(&info, 0, sizeof(info));
     SDL_GetVersion(&info);
 
@@ -925,6 +1025,13 @@ void sdl_display_init(DisplayState *ds,
         return;
     }
 
+#if SDL_VERSION_ATLEAST(2, 26, 0)
+    if (opts->has_clipboard && opts->clipboard) {
+        qemu_add_clipboard_notifier(&sdl_clipboard_notifier);
+        info("SDL clipboard integration enabled");
+    }
+#endif
+
     if (opts->gl == DISPLAYGL_MODE_ES) {
         SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK,
                             SDL_GL_CONTEXT_PROFILE_ES);
