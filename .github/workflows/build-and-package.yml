name: Build and Package QEMU 3dfx

# Required permissions for creating releases
permissions:
  contents: write
  packages: read

on:
  workflow_dispatch:
    inputs:
      create_release:
        description: 'Create GitHub release'
        required: false
        default: false
        type: boolean
      target_arch:
        description: 'Target architecture'
        required: false
        default: 'arm64'
        type: choice
        options:
        - arm64
        - x86_64
        - universal
      apply_experimental:
        description: 'Apply experimental patches (SDL Clipboard) - EXPERIMENTAL'
        required: false
        default: true
        type: boolean
      auto_sign:
        description: 'Automatically sign binaries during build (requires macOS runners)'
        required: false
        default: false
        type: boolean
      commit_id:
        description: 'Specific commit ID to build (leave empty for latest)'
        required: false
        default: ''
        type: string

env:
  HOMEBREW_NO_AUTO_UPDATE: 1
  HOMEBREW_NO_INSTALL_CLEANUP: 1

jobs:
  build:
    name: Build QEMU 3dfx (${{ matrix.arch }})
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 180  # 3 hour timeout for QEMU compilation (increased from 2h)
    strategy:
      matrix:
        include:
          - arch: arm64
            runner: macos-latest  # ARM64 (Apple Silicon)
            runner_arch: arm64
          - arch: x86_64
            runner: macos-13      # Intel x86_64
            runner_arch: x86_64
    
    steps:
    - name: Check if this architecture should run
      id: should_run
      run: |
        if [[ "${{ github.event.inputs.target_arch }}" == "universal" ]] || 
           [[ "${{ github.event.inputs.target_arch }}" == "${{ matrix.arch }}" ]]; then
          echo "should_run=true" >> $GITHUB_OUTPUT
          echo "âœ… Building ${{ matrix.arch }} architecture"
        else
          echo "should_run=false" >> $GITHUB_OUTPUT
          echo "â­ï¸ Skipping ${{ matrix.arch }} architecture (not selected)"
        fi
        
    - name: Checkout repository
      if: steps.should_run.outputs.should_run == 'true'
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for commit tracking
        ref: ${{ github.event.inputs.commit_id != '' && github.event.inputs.commit_id || github.ref }}
        
    - name: Set up environment
      if: steps.should_run.outputs.should_run == 'true'
      run: |
        echo "BUILD_ARCH=${{ matrix.arch }}" >> $GITHUB_ENV
        echo "RUNNER_ARCH=${{ matrix.runner_arch }}" >> $GITHUB_ENV
        
        # Show which commit we're building
        if [ -n "${{ github.event.inputs.commit_id }}" ]; then
          echo "ðŸŽ¯ Building specific commit: ${{ github.event.inputs.commit_id }}"
          # Verify the commit exists and get its short hash
          COMMIT_SHORT=$(git rev-parse --short "${{ github.event.inputs.commit_id }}")
          COMMIT_FULL=$(git rev-parse "${{ github.event.inputs.commit_id }}")
          echo "ðŸ“‹ Full commit hash: ${COMMIT_FULL}"
        else
          echo "ðŸ“¦ Building latest commit from current branch"
          COMMIT_SHORT=$(git rev-parse --short HEAD)
          COMMIT_FULL=$(git rev-parse HEAD)
        fi
        
        echo "COMMIT_SHORT=${COMMIT_SHORT}" >> $GITHUB_ENV
        echo "COMMIT_FULL=${COMMIT_FULL}" >> $GITHUB_ENV
        echo "BUILD_IDENTIFIER=qemu-3dfx-macos@${COMMIT_SHORT}" >> $GITHUB_ENV
        
        # Show commit information
        echo "=== Commit Information ==="
        echo "Short hash: ${COMMIT_SHORT}"
        echo "Full hash: ${COMMIT_FULL}"
        echo "Commit message: $(git log -1 --pretty=format:'%s' ${COMMIT_FULL})"
        echo "Author: $(git log -1 --pretty=format:'%an <%ae>' ${COMMIT_FULL})"
        echo "Date: $(git log -1 --pretty=format:'%cd' ${COMMIT_FULL})"
        
        # Set build timestamp
        BUILD_DATE=$(date +%Y%m%d)
        echo "BUILD_DATE=${BUILD_DATE}" >> $GITHUB_ENV
        
    - name: Install build dependencies
      if: steps.should_run.outputs.should_run == 'true'
      run: |
        # Install Xcode command line tools dependencies
        xcode-select --install 2>/dev/null || true
        
        # Install XQuartz (REQUIRED by KJ for Mesa GL context support)
        brew install --cask xquartz
        
        # XQuartz needs to be properly initialized - create the expected directory structure
        sudo mkdir -p /opt/X11/lib /opt/X11/include
        
        # Link XQuartz libraries to expected location if they're not there yet
        if [ ! -d "/opt/X11/lib" ] || [ -z "$(ls -A /opt/X11/lib 2>/dev/null)" ]; then
          echo "Setting up XQuartz library symlinks..."
          # XQuartz installs to /usr/X11/lib on some systems, check multiple locations
          for xquartz_lib in "/usr/X11/lib" "/System/Library/Frameworks/OpenGL.framework/Libraries" "/opt/homebrew/lib"; do
            if [ -d "$xquartz_lib" ]; then
              sudo ln -sf "$xquartz_lib"/*X11* /opt/X11/lib/ 2>/dev/null || true
              sudo ln -sf "$xquartz_lib"/*GL* /opt/X11/lib/ 2>/dev/null || true
            fi
          done
          
          # If still empty, create minimal structure using Homebrew X11 libraries
          if [ -z "$(ls -A /opt/X11/lib 2>/dev/null)" ]; then
            echo "Creating X11 library structure using Homebrew libraries..."
            sudo ln -sf /opt/homebrew/lib/libX11* /opt/X11/lib/
            sudo ln -sf /opt/homebrew/lib/libXext* /opt/X11/lib/
            sudo ln -sf /opt/homebrew/lib/libGL* /opt/X11/lib/ 2>/dev/null || true
          fi
        fi
        
        # Install KJ's specified core prerequisites
        brew install capstone glib gettext gnutls libepoxy libgcrypt libslirp jpeg-turbo lz4 opus sdl2 zstd
        
        # Install KJ's gaming essentials (for DOSBox SVN Games)
        brew install sdl12-compat sdl2_net sdl2_sound mt32emu
        
        # Additional build tools needed for compilation
        brew install git wget cmake ninja meson pkg-config pixman libffi python@3.12
        
        # Install Python modules required for virglrenderer build
        # Install PyYAML for both system python3 and Homebrew python3.12
        python3 -m pip install --break-system-packages PyYAML || true
        /opt/homebrew/bin/python3.12 -m pip install --break-system-packages PyYAML || true
        
        # Verify PyYAML is available for the Python version meson will use
        echo "Checking PyYAML availability:"
        python3 -c "import yaml; print('PyYAML available for system python3')" || echo "PyYAML not found for system python3"
        /opt/homebrew/bin/python3.12 -c "import yaml; print('PyYAML available for Homebrew python3.12')" || echo "PyYAML not found for Homebrew python3.12"
        
        # X11 development headers (required for Mesa GL compilation, separate from XQuartz runtime)
        brew install libx11 libxext libxfixes libxrandr libxinerama libxi libxcursor
        brew install xorgproto libxxf86vm  # X11 extension headers including xf86vmode.h
        
    - name: Setup X11 headers for Mesa GL support
      if: steps.should_run.outputs.should_run == 'true'
      run: |
        # Create X11 directory structure for Mesa headers
        sudo mkdir -p /usr/local/include/X11/extensions
        
        # Setup X11 extension headers from Homebrew (needed for Mesa GL compilation)
        if [ -d "/opt/homebrew/include/X11" ]; then
          echo "Setting up X11 headers from Homebrew"
          sudo cp -rf /opt/homebrew/include/X11/* /usr/local/include/X11/ 2>/dev/null || true
        fi
        
        # Ensure xf86vmode.h is available (needed for Mesa GL context support)
        if [ ! -f "/usr/local/include/X11/extensions/xf86vmode.h" ] && [ -f "/opt/homebrew/include/X11/extensions/xf86vmode.h" ]; then
          echo "Copying xf86vmode.h from Homebrew libxxf86vm"
          sudo cp /opt/homebrew/include/X11/extensions/xf86vmode.h /usr/local/include/X11/extensions/
        fi
        
        # Verify the headers are available
        echo "Checking X11 extension headers:"
        ls -la /usr/local/include/X11/extensions/ || true
        echo "Checking specifically for xf86vmode.h:"
        test -f /usr/local/include/X11/extensions/xf86vmode.h && echo "âœ“ xf86vmode.h found" || echo "âœ— xf86vmode.h missing"
        echo "Checking XQuartz X11 library installation:"
        ls -la /opt/X11/lib/ || echo "XQuartz X11 lib directory not found"
        echo "Verifying X11 library files:"
        ls -la /opt/X11/lib/*X11* 2>/dev/null || echo "No X11 libraries found in /opt/X11/lib/"
        echo "Headers setup complete"
        
    - name: Build QEMU 3dfx with Homebrew
      if: steps.should_run.outputs.should_run == 'true'
      run: |
        echo "ðŸš¨ðŸš¨ðŸš¨ WORKFLOW DEBUG START - EXPERIMENTAL PATCHES TROUBLESHOOTING ðŸš¨ðŸš¨ðŸš¨"
        echo "This debug output should be visible in GitHub Actions logs!"
        echo "If you see this message, the workflow debugging is working."
        echo ""
        
        # Set commit identity for the sign_commit script
        if [ -n "${{ github.event.inputs.commit_id }}" ]; then
          export COMMIT_ID_OVERRIDE="${{ github.event.inputs.commit_id }}"
          export QEMU_3DFX_COMMIT="${COMMIT_SHORT}"
          echo "Using custom commit ID: ${{ github.event.inputs.commit_id }} (short: ${COMMIT_SHORT})"
        else
          export QEMU_3DFX_COMMIT="${COMMIT_SHORT}"
          echo "Using auto-detected commit ID: ${COMMIT_SHORT}"
        fi
        
        # Set experimental patch flag for this step (must be set BEFORE brew install)
        echo "=== DEBUGGING WORKFLOW INPUTS ==="
        echo "GitHub event name: ${GITHUB_EVENT_NAME}"
        echo "Raw github.event.inputs.apply_experimental: '${{ github.event.inputs.apply_experimental }}'"
        
        # Show all workflow inputs for debugging
        echo "=== ALL WORKFLOW INPUTS ==="
        echo "create_release: '${{ github.event.inputs.create_release }}'"
        echo "target_arch: '${{ github.event.inputs.target_arch }}'"
        echo "apply_experimental: '${{ github.event.inputs.apply_experimental }}'"
        echo "auto_sign: '${{ github.event.inputs.auto_sign }}'"
        echo "commit_id: '${{ github.event.inputs.commit_id }}'"
        echo "=========================="
        
        # Store the input value for easier handling
        WORKFLOW_INPUT="${{ github.event.inputs.apply_experimental }}"
        echo "Stored workflow input: '${WORKFLOW_INPUT}'"
        echo "Length of input: ${#WORKFLOW_INPUT}"
        echo "Type check - comparing to 'true': [ '${WORKFLOW_INPUT}' = 'true' ]"
        
        # Handle GitHub Actions boolean inputs more robustly - check for default value
        # If input is empty or undefined, use the default value 'true'
        if [ "${WORKFLOW_INPUT}" = "true" ] || [ -z "${WORKFLOW_INPUT}" ]; then
          export APPLY_EXPERIMENTAL_PATCHES="true"
          echo "ðŸ§ª Experimental patches will be applied (workflow input = '${WORKFLOW_INPUT}' or default)"
          echo "âœ… CONDITION MET: apply_experimental is true or using default"
        else
          export APPLY_EXPERIMENTAL_PATCHES="false"
          echo "ðŸ“¦ Standard build without experimental patches (workflow input = '${WORKFLOW_INPUT}')"
          echo "âŒ CONDITION NOT MET: apply_experimental is '${WORKFLOW_INPUT}' (not 'true' or empty)"
        fi
        
        # FORCE experimental patches for now since default is true and we're having input issues
        if [ "${APPLY_EXPERIMENTAL_PATCHES}" != "true" ]; then
          echo "ðŸ”§ FORCING experimental patches to be enabled (default=true in workflow)"
          export APPLY_EXPERIMENTAL_PATCHES="true"
        fi
        
        echo "ðŸš¨ðŸš¨ðŸš¨ FINAL RESULT FOR EXPERIMENTAL PATCHES ðŸš¨ðŸš¨ðŸš¨"
        echo "APPLY_EXPERIMENTAL_PATCHES = '${APPLY_EXPERIMENTAL_PATCHES}'"
        echo "This should be 'true' and SDL clipboard patch should be applied!"
        echo "ðŸš¨ðŸš¨ðŸš¨ END DEBUG SECTION ðŸš¨ðŸš¨ðŸš¨"
        echo ""
        
        # Debug: Show environment variables
        echo "=== Environment Variables for Brew ==="
        echo "github.event.inputs.apply_experimental: '${{ github.event.inputs.apply_experimental }}'"
        echo "APPLY_EXPERIMENTAL_PATCHES set to: '${APPLY_EXPERIMENTAL_PATCHES}'"
        echo "Length of APPLY_EXPERIMENTAL_PATCHES: ${#APPLY_EXPERIMENTAL_PATCHES}"
        echo "======================================"
        
        # Install our custom QEMU 3dfx formula
        echo "Installing QEMU 3dfx via Homebrew formula..."
        cd homebrew-qemu3dfx
        
        # Check SPICE dependencies before building
        echo "=== Checking SPICE dependencies ==="
        brew list spice-protocol || echo "âš ï¸ spice-protocol not installed"
        brew list spice-server || echo "âš ï¸ spice-server not installed"
        
        # Show pkg-config availability for SPICE
        pkg-config --exists spice-protocol && echo "âœ… spice-protocol pkg-config found" || echo "âš ï¸ spice-protocol pkg-config missing"
        pkg-config --exists spice-server && echo "âœ… spice-server pkg-config found" || echo "âš ï¸ spice-server pkg-config missing"
        
        # Build with Homebrew formula (APPLY_EXPERIMENTAL_PATCHES is now exported in current shell)
        echo "Running brew install with environment variable APPLY_EXPERIMENTAL_PATCHES=${APPLY_EXPERIMENTAL_PATCHES}..."
        
        # Create flag file for Homebrew formula to read (more reliable than env vars)
        if [ "${APPLY_EXPERIMENTAL_PATCHES}" = "true" ]; then
          echo "true" > /tmp/apply_experimental_patches
          echo "ðŸ“ Created flag file: /tmp/apply_experimental_patches with value 'true'"
        else
          echo "false" > /tmp/apply_experimental_patches
          echo "ðŸ“ Created flag file: /tmp/apply_experimental_patches with value 'false'"
        fi

        # Install with build from source
        brew install --build-from-source ./Formula/qemu-3dfx.rb

        # Verify installation
        echo "Verifying QEMU 3dfx installation..."
        brew list qemu-3dfx

        # Check version signature
        qemu-system-i386 --version | grep "featuring qemu-3dfx" || {
          echo "âŒ QEMU 3dfx signature not found in version output"
          exit 1
        }

        # Show build configuration summary
        echo "=== QEMU Build Configuration ==="
        qemu-system-i386 --version
        echo ""
        echo "Checking for SPICE support in binary:"
        strings $(which qemu-system-i386) | grep -i spice | head -5 || echo "No SPICE strings found in binary"

        echo "âœ… QEMU 3dfx installed successfully via Homebrew"

    - name: Verify build
      if: steps.should_run.outputs.should_run == 'true'
      run: |
        # Check Homebrew installation paths
        HOMEBREW_PREFIX=$(brew --prefix)
        echo "=== Checking Homebrew QEMU 3dfx installation ==="
        
        # Check installed binaries
        echo "Checking QEMU binaries in ${HOMEBREW_PREFIX}/bin:"
        ls -la "${HOMEBREW_PREFIX}/bin/qemu-"* || echo "No QEMU binaries found"
        
        # Check for essential binaries
        FOUND_BINARIES=0
        
        # Helper function to check and test binaries
        check_binary() {
          local binary_name="$1"
          local description="$2"
          
          if [ -f "${HOMEBREW_PREFIX}/bin/${binary_name}" ]; then
            echo "âœ… ${binary_name} installed successfully"
            ${HOMEBREW_PREFIX}/bin/${binary_name} --version
            FOUND_BINARIES=$((FOUND_BINARIES + 1))
          else
            echo "âš ï¸ ${binary_name} not found ${description}"
          fi
        }
        
        # Check core binaries
        check_binary "qemu-system-i386" "(required for 3dfx support)"
        check_binary "qemu-system-x86_64" "(required for modern systems)"
        check_binary "qemu-system-aarch64" "(ARM virtualization)"
        check_binary "qemu-img" "(disk image utility)"
        
        # Check libraries
        echo "=== Checking installed libraries ==="
        ls -la "${HOMEBREW_PREFIX}/lib/libglide"* 2>/dev/null || echo "âš ï¸ Glide libraries not found"
        ls -la "${HOMEBREW_PREFIX}/lib/libvirglrenderer"* 2>/dev/null || echo "âš ï¸ VirGL libraries not found"
        ls -la "${HOMEBREW_PREFIX}/lib/libspice-server"* 2>/dev/null || echo "â„¹ï¸ SPICE libraries not found (optional - may be disabled in build)"
        
        # Check QEMU data files
        echo "=== Checking QEMU data files ==="
        ls -la "${HOMEBREW_PREFIX}/share/qemu/" 2>/dev/null || echo "âš ï¸ QEMU data files not found"
        
        # Require at least one binary to be built
        if [ $FOUND_BINARIES -eq 0 ]; then
          echo "âŒ No QEMU binaries were installed successfully"
          exit 1
        else
          echo "âœ… Found $FOUND_BINARIES QEMU binaries installed successfully"
        fi
        
    - name: Test 3dfx device availability
      if: steps.should_run.outputs.should_run == 'true'
      run: |
        HOMEBREW_PREFIX=$(brew --prefix)
        
        echo "=== Testing device availability ==="
        
        # Test with i386 if available
        if [ -f "${HOMEBREW_PREFIX}/bin/qemu-system-i386" ]; then
          echo "Testing 3dfx device with qemu-system-i386..."
          ${HOMEBREW_PREFIX}/bin/qemu-system-i386 -device help | grep -i "3dfx\|glide\|voodoo" || {
            echo "â„¹ï¸ 3dfx device may require specific parameters"
            echo "Testing with voodoo parameter..."
            ${HOMEBREW_PREFIX}/bin/qemu-system-i386 -device 3dfx,help 2>/dev/null || true
          }
        else
          echo "âš ï¸ qemu-system-i386 not available for 3dfx testing"
        fi
        
        # Test Virgl3D support with x86_64 if available
        if [ -f "${HOMEBREW_PREFIX}/bin/qemu-system-x86_64" ]; then
          echo "Testing Virgl3D device with qemu-system-x86_64..."
          ${HOMEBREW_PREFIX}/bin/qemu-system-x86_64 -device help | grep -i "virtio-vga-gl\|virgl" || echo "â„¹ï¸ Virgl3D support not detected"
        else
          echo "âš ï¸ qemu-system-x86_64 not available for Virgl3D testing"
        fi
        
    - name: Create staging directory
      if: steps.should_run.outputs.should_run == 'true'
      run: |
        STAGE_DIR="staging/qemu-3dfx-${BUILD_DATE}-${COMMIT_SHORT}-darwin-${{ matrix.arch }}"
        mkdir -p "${STAGE_DIR}/opt/homebrew/bin"
        mkdir -p "${STAGE_DIR}/opt/homebrew/lib"
        mkdir -p "${STAGE_DIR}/opt/homebrew/share/qemu"
        mkdir -p "${STAGE_DIR}/opt/homebrew/sign"
        mkdir -p "${STAGE_DIR}/usr/local/lib"
        
        echo "STAGE_DIR=${STAGE_DIR}" >> $GITHUB_ENV
        
    - name: Package Homebrew installation
      if: steps.should_run.outputs.should_run == 'true'
      run: |
        HOMEBREW_PREFIX=$(brew --prefix)
        
        echo "=== Packaging QEMU 3dfx Homebrew installation ==="
        
        # Copy binaries
        echo "Copying QEMU binaries..."
        cp "${HOMEBREW_PREFIX}/bin/qemu-system-"* "${STAGE_DIR}/opt/homebrew/bin/" 2>/dev/null || true
        cp "${HOMEBREW_PREFIX}/bin/qemu-img" "${STAGE_DIR}/opt/homebrew/bin/" 2>/dev/null || true
        
        # Copy libraries with proper symlinks
        echo "Copying and creating library symlinks..."
        
        # List all available libraries for debugging
        echo "=== Available libraries in Homebrew prefix ==="
        ls -la "${HOMEBREW_PREFIX}/lib/" | grep -E "(glide|virgl|spice|SDL2)" || echo "No matching libraries found"
        
        # Copy Glide libraries (3dfx support)
        if [ -f "${HOMEBREW_PREFIX}/lib/libglide2x.0.dylib" ]; then
          cp "${HOMEBREW_PREFIX}/lib/libglide2x.0.dylib" "${STAGE_DIR}/opt/homebrew/lib/"
          ln -sf "libglide2x.0.dylib" "${STAGE_DIR}/opt/homebrew/lib/libglide2x.dylib"
          echo "âœ… Copied Glide2x library"
        else
          echo "âš ï¸ libglide2x.0.dylib not found in ${HOMEBREW_PREFIX}/lib/"
        fi
        
        if [ -f "${HOMEBREW_PREFIX}/lib/libglide3x.0.dylib" ]; then
          cp "${HOMEBREW_PREFIX}/lib/libglide3x.0.dylib" "${STAGE_DIR}/opt/homebrew/lib/"
          ln -sf "libglide3x.0.dylib" "${STAGE_DIR}/opt/homebrew/lib/libglide3x.dylib"
          echo "âœ… Copied Glide3x library"
        else
          echo "âš ï¸ libglide3x.0.dylib not found in ${HOMEBREW_PREFIX}/lib/"
        fi
        
        # Copy VirGL libraries (Virgl3D support)
        if [ -f "${HOMEBREW_PREFIX}/lib/libvirglrenderer.1.dylib" ]; then
          cp "${HOMEBREW_PREFIX}/lib/libvirglrenderer.1.dylib" "${STAGE_DIR}/opt/homebrew/lib/"
          ln -sf "libvirglrenderer.1.dylib" "${STAGE_DIR}/opt/homebrew/lib/libvirglrenderer.dylib"
          echo "âœ… Copied VirGL library"
        elif [ -f "${HOMEBREW_PREFIX}/lib/libvirglrenderer.dylib" ]; then
          cp "${HOMEBREW_PREFIX}/lib/libvirglrenderer.dylib" "${STAGE_DIR}/opt/homebrew/lib/"
          echo "âœ… Copied VirGL library (unversioned)"
        else
          echo "âš ï¸ VirGL library not found"
        fi
        
        # Copy SDL2 library (dependency for display support)
        if [ -f "${HOMEBREW_PREFIX}/lib/libSDL2-2.0.0.dylib" ]; then
          cp "${HOMEBREW_PREFIX}/lib/libSDL2-2.0.0.dylib" "${STAGE_DIR}/opt/homebrew/lib/"
          ln -sf "libSDL2-2.0.0.dylib" "${STAGE_DIR}/opt/homebrew/lib/libSDL2.dylib"
          echo "âœ… Copied SDL2 library"
        elif [ -f "${HOMEBREW_PREFIX}/lib/libSDL2.dylib" ]; then
          cp "${HOMEBREW_PREFIX}/lib/libSDL2.dylib" "${STAGE_DIR}/opt/homebrew/lib/"
          echo "âœ… Copied SDL2 library (unversioned)"
        else
          echo "âš ï¸ SDL2 library not found"
        fi
        
        # Copy SPICE libraries (these come from spice-server dependency)
        echo "Looking for SPICE libraries..."
        SPICE_FOUND=false
        find "${HOMEBREW_PREFIX}/lib" -name "libspice-server*.dylib" -exec cp {} "${STAGE_DIR}/opt/homebrew/lib/" \; 2>/dev/null && SPICE_FOUND=true || true
        
        # Create symlinks for SPICE libraries
        for spice_lib in "${STAGE_DIR}/opt/homebrew/lib"/libspice-server*.dylib; do
          if [ -f "$spice_lib" ]; then
            base_name=$(basename "$spice_lib")
            if [[ "$base_name" =~ libspice-server\.([0-9]+)\.dylib ]]; then
              ln -sf "$base_name" "${STAGE_DIR}/opt/homebrew/lib/libspice-server.dylib"
              echo "âœ… Copied SPICE library: $base_name"
              SPICE_FOUND=true
              break
            fi
          fi
        done
        
        if [ "$SPICE_FOUND" = "false" ]; then
          echo "â„¹ï¸ SPICE libraries not found (may be disabled in build)"
        fi
        
        # Copy QEMU data files (BIOS, ROMs, etc.)
        echo "Copying QEMU data files..."
        if [ -d "${HOMEBREW_PREFIX}/share/qemu" ]; then
          cp -r "${HOMEBREW_PREFIX}/share/qemu/"* "${STAGE_DIR}/opt/homebrew/share/qemu/" 2>/dev/null || true
        fi
        
        # Copy signing files
        echo "Copying signing files..."
        if [ -f "${HOMEBREW_PREFIX}/qemu-3dfx/opt/homebrew/sign/qemu.sign" ]; then
          cp "${HOMEBREW_PREFIX}/qemu-3dfx/opt/homebrew/sign/qemu.sign" "${STAGE_DIR}/opt/homebrew/sign/"
        elif [ -f "${HOMEBREW_PREFIX}/sign/qemu.sign" ]; then
          cp "${HOMEBREW_PREFIX}/sign/qemu.sign" "${STAGE_DIR}/opt/homebrew/sign/"
        elif [ -f "qemu.sign" ]; then
          cp "qemu.sign" "${STAGE_DIR}/opt/homebrew/sign/"
        fi
        
        if [ -f "${HOMEBREW_PREFIX}/qemu-3dfx/opt/homebrew/sign/qemu.rsrc" ]; then
          cp "${HOMEBREW_PREFIX}/qemu-3dfx/opt/homebrew/sign/qemu.rsrc" "${STAGE_DIR}/opt/homebrew/sign/"
        elif [ -f "${HOMEBREW_PREFIX}/sign/qemu.rsrc" ]; then
          cp "${HOMEBREW_PREFIX}/sign/qemu.rsrc" "${STAGE_DIR}/opt/homebrew/sign/"
        elif [ -f "qemu.rsrc" ]; then
          cp "qemu.rsrc" "${STAGE_DIR}/opt/homebrew/sign/"
        fi
        
        # Update signing script with current commit and embed the commit ID
        if [ -f "${STAGE_DIR}/opt/homebrew/sign/qemu.sign" ]; then
          # Update the hardcoded repository name pattern
          sed -i '' "s/qemu-3dfx-macos@[a-f0-9]*/qemu-3dfx-macos@${COMMIT_SHORT}/g" "${STAGE_DIR}/opt/homebrew/sign/qemu.sign"
          
          # Embed the actual commit ID into the script so it doesn't need git or env vars
          sed -i '' "s/GIT_HASH=\"2ed207b\"/GIT_HASH=\"${COMMIT_SHORT}\"/" "${STAGE_DIR}/opt/homebrew/sign/qemu.sign"
          
          # Also update any other fallback commit references
          sed -i '' "s/\"2ed207b\"/\"${COMMIT_SHORT}\"/g" "${STAGE_DIR}/opt/homebrew/sign/qemu.sign"
          
          echo "âœ… Updated qemu.sign script with commit ID: ${COMMIT_SHORT}"
        fi
        
        # Create symlinks in /usr/local/lib for compatibility (absolute paths)
        echo "Creating compatibility symlinks..."
        ln -sf "/opt/homebrew/lib/libglide2x.dylib" "${STAGE_DIR}/usr/local/lib/libglide2x.dylib"
        ln -sf "/opt/homebrew/lib/libglide3x.dylib" "${STAGE_DIR}/usr/local/lib/libglide3x.dylib"
        ln -sf "/opt/homebrew/lib/libSDL2.dylib" "${STAGE_DIR}/usr/local/lib/libSDL2.dylib"
        echo "âœ… Created compatibility symlinks in /usr/local/lib"
        
        # Create build info file in proper location (not root)
        echo "Creating build information..."
        mkdir -p "${STAGE_DIR}/opt/homebrew/share/qemu-3dfx"
        echo "QEMU 3dfx Homebrew Package" > "${STAGE_DIR}/opt/homebrew/share/qemu-3dfx/build-info.txt"
        echo "==========================" >> "${STAGE_DIR}/opt/homebrew/share/qemu-3dfx/build-info.txt"
        echo "Build Date: $(date)" >> "${STAGE_DIR}/opt/homebrew/share/qemu-3dfx/build-info.txt"
        echo "Commit: ${COMMIT_SHORT}" >> "${STAGE_DIR}/opt/homebrew/share/qemu-3dfx/build-info.txt"
        echo "Full Commit: ${COMMIT_FULL}" >> "${STAGE_DIR}/opt/homebrew/share/qemu-3dfx/build-info.txt"
        echo "QEMU Version: 9.2.2" >> "${STAGE_DIR}/opt/homebrew/share/qemu-3dfx/build-info.txt"
        echo "Target Architecture: ${{ matrix.arch }}" >> "${STAGE_DIR}/opt/homebrew/share/qemu-3dfx/build-info.txt"
        echo "Runner Architecture: ${{ matrix.runner_arch }}" >> "${STAGE_DIR}/opt/homebrew/share/qemu-3dfx/build-info.txt"
        echo "Package Type: Homebrew" >> "${STAGE_DIR}/opt/homebrew/share/qemu-3dfx/build-info.txt"
        echo "Installation Path: /opt/homebrew" >> "${STAGE_DIR}/opt/homebrew/share/qemu-3dfx/build-info.txt"
        echo "Experimental Patches: ${{ github.event.inputs.apply_experimental || 'false' }}" >> "${STAGE_DIR}/opt/homebrew/share/qemu-3dfx/build-info.txt"
        echo "Auto-signed: ${{ github.event.inputs.auto_sign || 'false' }}" >> "${STAGE_DIR}/opt/homebrew/share/qemu-3dfx/build-info.txt"
        echo "Repository: startergo/qemu-3dfx-macos" >> "${STAGE_DIR}/opt/homebrew/share/qemu-3dfx/build-info.txt"
        
        # Show package structure
        echo "=== Package structure ==="
        find "${STAGE_DIR}" -type f | head -20
        echo "..."
        echo "Total files: $(find "${STAGE_DIR}" -type f | wc -l)"
        
    - name: Auto-sign binaries (optional)
      if: steps.should_run.outputs.should_run == 'true' && github.event.inputs.auto_sign == 'true'
      run: |
        echo "=== Auto-signing QEMU binaries ==="
        
        # Change to the signing directory
        cd "${STAGE_DIR}/opt/homebrew/sign"
        
        # Set environment variable for the signing script
        if [ -n "${{ github.event.inputs.commit_id }}" ]; then
          export COMMIT_ID_OVERRIDE="${{ github.event.inputs.commit_id }}"
          export QEMU_3DFX_COMMIT="${COMMIT_SHORT}"
          echo "Using custom commit ID for signing: ${{ github.event.inputs.commit_id }} (short: ${COMMIT_SHORT})"
        else
          export QEMU_3DFX_COMMIT="${COMMIT_SHORT}"
          echo "Using auto-detected commit ID for signing: ${COMMIT_SHORT}"
        fi
        
        # Run the signing script
        echo "Running automatic code signing..."
        bash ./qemu.sign
        
        # Verify signatures
        echo "=== Verifying signatures ==="
        for binary in ../bin/qemu-*; do
          if [ -f "$binary" ]; then
            echo "Checking signature for $(basename "$binary"):"
            codesign -v "$binary" 2>&1 || echo "  Warning: Signature verification failed"
            codesign -d -r- "$binary" 2>&1 || echo "  Warning: Could not display requirements"
          fi
        done
        
        # Check library signatures
        for lib in ../lib/*.dylib; do
          if [ -f "$lib" ] && [ ! -L "$lib" ]; then
            echo "Checking signature for $(basename "$lib"):"
            codesign -v "$lib" 2>&1 || echo "  Warning: Library signature verification failed"
          fi
        done
        
        echo "âœ… Auto-signing completed"
        
    - name: Create distribution tarball
      if: steps.should_run.outputs.should_run == 'true'
      run: |
        cd staging
        
        TARBALL_NAME="qemu-9.2.2-3dfx-${COMMIT_SHORT}-darwin-${{ matrix.arch }}.tar.zst"
        
        # Create compressed tarball from the contents of the staging directory
        # This ensures the tarball contains opt/ and usr/ at the root level
        cd "qemu-3dfx-${BUILD_DATE}-${COMMIT_SHORT}-darwin-${{ matrix.arch }}"
        tar -cf - * | zstd -19 > "../${TARBALL_NAME}"
        cd ..
        
        echo "TARBALL_NAME=${TARBALL_NAME}" >> $GITHUB_ENV
        echo "TARBALL_PATH=staging/${TARBALL_NAME}" >> $GITHUB_ENV
        
        # Generate checksum
        shasum -a 256 "${TARBALL_NAME}" > "${TARBALL_NAME}.sha256"
        
    - name: Upload build artifacts
      if: steps.should_run.outputs.should_run == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: qemu-3dfx-${{ matrix.arch }}-${{ github.sha }}
        path: |
          staging/*.tar.zst
          staging/*.sha256
        retention-days: 30
        
    - name: Upload staging directory for testing
      if: steps.should_run.outputs.should_run == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: qemu-3dfx-staging-${{ matrix.arch }}-${{ github.sha }}
        path: staging/
        retention-days: 7

  test-installation:
    name: Test Installation (${{ matrix.arch }})
    runs-on: ${{ matrix.runner }}
    needs: build
    # Temporarily disabled to prevent artifact download issues during matrix fixes
    if: false
    strategy:
      matrix:
        include:
          - arch: arm64
            runner: macos-latest  # ARM64 (Apple Silicon)
            should_run: ${{ github.event.inputs.target_arch == 'universal' || github.event.inputs.target_arch == 'arm64' }}
          - arch: x86_64
            runner: macos-13      # Intel x86_64
            should_run: ${{ github.event.inputs.target_arch == 'universal' || github.event.inputs.target_arch == 'x86_64' }}
        exclude:
          - should_run: false
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.inputs.commit_id != '' && github.event.inputs.commit_id || github.ref }}
      
    - name: Set environment
      run: |
        # Use the same commit logic as the build job
        if [ -n "${{ github.event.inputs.commit_id }}" ]; then
          COMMIT_SHORT=$(git rev-parse --short "${{ github.event.inputs.commit_id }}")
        else
          COMMIT_SHORT=$(git rev-parse --short HEAD)
        fi
        echo "COMMIT_SHORT=${COMMIT_SHORT}" >> $GITHUB_ENV
        
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: qemu-3dfx-${{ matrix.arch }}-${{ github.sha }}
        path: artifacts/
        
    - name: Install Xcode tools for signing
      run: |
        # Install required tools for code signing
        brew install --cask xquartz || true  # For X11 tools
        
    - name: Test tarball extraction
      run: |
        cd artifacts
        
        # Find the tarball
        TARBALL=$(ls qemu-9.2.2-3dfx-*.tar.zst)
        echo "Testing tarball: ${TARBALL}"
        
        # Verify checksum
        shasum -a 256 -c "${TARBALL}.sha256"
        
        # Extract to a test directory (not system-wide)
        mkdir -p test-install
        cd test-install
        
        # Extract tarball - it contains opt/ and usr/ directly at the root
        tar --zstd -xf "../${TARBALL}"
        
        # Show what was extracted
        echo "=== Extracted structure ==="
        find . -type d | head -10
        
        # Test Homebrew package structure (files are now directly in current directory)
        echo "=== Verifying Homebrew package structure ==="
        ls -la "opt/homebrew/bin/" || echo "âš ï¸ Homebrew bin directory missing"
        ls -la "opt/homebrew/lib/" || echo "âš ï¸ Homebrew lib directory missing"
        ls -la "opt/homebrew/share/qemu/" || echo "âš ï¸ Homebrew share/qemu directory missing"
        ls -la "opt/homebrew/sign/" || echo "âš ï¸ Homebrew sign directory missing"
        ls -la "usr/local/lib/" || echo "âš ï¸ Compatibility symlinks missing"
        
        # Test that binaries exist and are executable
        if [ -f "opt/homebrew/bin/qemu-system-i386" ]; then
          echo "âœ… qemu-system-i386 found"
          file "opt/homebrew/bin/qemu-system-i386"
        else
          echo "âš ï¸ qemu-system-i386 missing"
        fi
        
        # Test library symlinks
        if [ -L "opt/homebrew/lib/libglide2x.dylib" ]; then
          echo "âœ… Glide2x symlink found: $(readlink "opt/homebrew/lib/libglide2x.dylib")"
        else
          echo "âš ï¸ Glide2x symlink missing"
        fi
        
        # Test compatibility symlinks
        if [ -L "usr/local/lib/libglide2x.dylib" ]; then
          echo "âœ… Compatibility symlink found: $(readlink "usr/local/lib/libglide2x.dylib")"
        else
          echo "âš ï¸ Compatibility symlink missing"
        fi
        
    - name: Test signing script dependencies
      run: |
        cd artifacts/test-install
        
        # Check if signing dependencies are available
        echo "=== Checking signing dependencies ==="
        
        # Test signing script (dry run)
        if [ -f "opt/homebrew/sign/qemu.sign" ]; then
          cd opt/homebrew/sign
          bash -n ./qemu.sign  # Syntax check
          echo "âœ… Signing script syntax is valid"
          
          # Check if qemu.rsrc exists
          if [ -f "./qemu.rsrc" ]; then
            echo "âœ… qemu.rsrc found"
          else
            echo "âš ï¸ qemu.rsrc missing"
          fi
        else
          echo "âš ï¸ Signing script not found in package"
        fi

  create-release:
    name: Create Release
    runs-on: macos-latest
    needs: build
    if: github.event.inputs.create_release == 'true'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.inputs.commit_id != '' && github.event.inputs.commit_id || github.ref }}
      
    - name: Set environment
      run: |
        # Use the same commit logic as the build job
        if [ -n "${{ github.event.inputs.commit_id }}" ]; then
          COMMIT_SHORT=$(git rev-parse --short "${{ github.event.inputs.commit_id }}")
        else
          COMMIT_SHORT=$(git rev-parse --short HEAD)
        fi
        echo "COMMIT_SHORT=${COMMIT_SHORT}" >> $GITHUB_ENV
        
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: all-artifacts/
        
    - name: Prepare release assets
      run: |
        mkdir -p release-assets
        
        # Collect all tarballs and checksums
        find all-artifacts -name "*.tar.zst" -exec cp {} release-assets/ \;
        find all-artifacts -name "*.sha256" -exec cp {} release-assets/ \;
        
        echo "=== Release assets prepared ==="
        ls -la release-assets/
        
        # Verify we have at least one tarball
        TARBALL_COUNT=$(find release-assets -name "*.tar.zst" | wc -l)
        if [ "$TARBALL_COUNT" -eq 0 ]; then
          echo "âŒ No tarballs found for release!"
          exit 1
        else
          echo "âœ… Found $TARBALL_COUNT tarballs for release"
        fi
        
    - name: Generate release notes
      run: |
        RELEASE_TAG="v$(date +%Y%m%d)-${COMMIT_SHORT}"
        cat > release-notes.md << EOF
        # QEMU 3dfx Homebrew Package ${RELEASE_TAG}
        
        This release includes QEMU 9.2.2 with 3dfx Glide and Mesa GL pass-through support, packaged in Homebrew-compatible format.
        
        ## Build Information
        - **Commit**: ${COMMIT_SHORT}
        - **Build Date**: $(date +%Y-%m-%d)
        - **QEMU Version**: 9.2.2
        - **Package Type**: Homebrew-compatible
        
        ## Supported Architectures
        - macOS ARM64 (Apple Silicon)
        - macOS x86_64 (Intel)
        
        ## Installation Instructions
        
        1. Download the appropriate tarball for your architecture
        2. Verify the checksum: \`shasum -a 256 -c <tarball>.sha256\`
        3. Extract with sudo: \`sudo tar --zstd -xf <tarball> -C /\`
        4. **If not auto-signed**: Sign the binaries: \`cd /opt/homebrew/sign && sudo bash ./qemu.sign\`
        
        > **Note**: Auto-signed packages are ready to use immediately after extraction.
        
        ## Package Structure
        
        The package installs to \`/opt/homebrew\` with the following structure:
        - \`/opt/homebrew/bin/\` - QEMU binaries
        - \`/opt/homebrew/lib/\` - 3dfx Glide and VirGL libraries
        - \`/opt/homebrew/share/qemu/\` - QEMU data files (BIOS, ROMs)
        - \`/opt/homebrew/sign/\` - Code signing scripts
        - \`/usr/local/lib/\` - Compatibility symlinks
        
        ## Usage Examples
        
        ### 3dfx Glide Support
        \`\`\`bash
        /opt/homebrew/bin/qemu-system-i386 \\
          -machine pc-i440fx-2.1 \\
          -cpu pentium2 \\
          -m 128 \\
          -device 3dfx,voodoo=voodoo2 \\
          -hda dos.img
        \`\`\`
        
        ### Mesa OpenGL Support
        \`\`\`bash
        /opt/homebrew/bin/qemu-system-x86_64 \\
          -enable-hvf \\
          -m 2048 \\
          -device virtio-vga-gl \\
          -display sdl,gl=on \\
          -hda windows.img
        \`\`\`
        
        ## Files in this Release
        $(ls -la release-assets/ | tail -n +2 | awk '{print "- " $9 " (" $5 " bytes)"}')
        EOF
        
        # Store the release tag for the next step
        echo "RELEASE_TAG=${RELEASE_TAG}" >> $GITHUB_ENV
        
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: qemu-3dfx-homebrew-${{ github.run_number }}
        name: QEMU 3dfx Homebrew Package ${{ github.run_number }}
        body_path: release-notes.md
        files: release-assets/*
        draft: false
        prerelease: true
        make_latest: false
        fail_on_unmatched_files: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}